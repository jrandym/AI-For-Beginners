# ज्ञान प्रतिनिधित्व और विशेषज्ञ प्रणाली

![Symbolic AI सामग्री का सारांश](../../../../translated_images/ai-symbolic.715a30cb610411a6964d2e2f23f24364cb338a07cb4844c1f97084d366e586c3.hi.png)

> स्केच नोट [Tomomi Imura](https://twitter.com/girlie_mac) द्वारा

कृत्रिम बुद्धिमत्ता की खोज ज्ञान की खोज पर आधारित है, ताकि दुनिया को समझा जा सके जैसे मनुष्य करते हैं। लेकिन आप इसे कैसे कर सकते हैं?

## [प्री-व्याख्यान प्रश्नोत्तरी](https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/102)

AI के प्रारंभिक दिनों में, बुद्धिमान प्रणाली बनाने के लिए शीर्ष-से-नीचे दृष्टिकोण (जिस पर पिछले पाठ में चर्चा की गई थी) लोकप्रिय था। विचार यह था कि लोगों से ज्ञान को कुछ मशीन-पठनीय रूप में निकाला जाए, और फिर इसका उपयोग करके स्वचालित रूप से समस्याओं को हल किया जाए। यह दृष्टिकोण दो बड़े विचारों पर आधारित था:

* ज्ञान प्रतिनिधित्व
* तर्क

## ज्ञान प्रतिनिधित्व

Symbolic AI में एक महत्वपूर्ण अवधारणा है **ज्ञान**। यह *सूचना* या *डेटा* से ज्ञान को अलग करना महत्वपूर्ण है। उदाहरण के लिए, कोई यह कह सकता है कि किताबों में ज्ञान होता है, क्योंकि कोई किताबों का अध्ययन करके विशेषज्ञ बन सकता है। हालाँकि, किताबों में जो होता है उसे वास्तव में *डेटा* कहा जाता है, और किताबों को पढ़कर और इस डेटा को अपने विश्व मॉडल में एकीकृत करके हम इस डेटा को ज्ञान में परिवर्तित करते हैं।

> ✅ **ज्ञान** वह है जो हमारे सिर में होता है और यह हमारे दुनिया की समझ का प्रतिनिधित्व करता है। इसे एक सक्रिय **अधिगम** प्रक्रिया द्वारा प्राप्त किया जाता है, जो कि हम जो जानकारी प्राप्त करते हैं, उसे हमारे सक्रिय विश्व मॉडल में एकीकृत करता है।

अधिकतर, हम ज्ञान को सख्ती से परिभाषित नहीं करते, बल्कि इसे [DIKW Pyramid](https://en.wikipedia.org/wiki/DIKW_pyramid) का उपयोग करके अन्य संबंधित अवधारणाओं के साथ संरेखित करते हैं। इसमें निम्नलिखित अवधारणाएँ शामिल हैं:

* **डेटा** कुछ ऐसा है जो भौतिक मीडिया में प्रस्तुत किया गया है, जैसे लिखित पाठ या बोले गए शब्द। डेटा मानव प्राणियों से स्वतंत्र रूप से मौजूद है और इसे लोगों के बीच पारित किया जा सकता है।
* **सूचना** वह है कि हम अपने सिर में डेटा की व्याख्या कैसे करते हैं। उदाहरण के लिए, जब हम *कंप्यूटर* शब्द सुनते हैं, तो हमें इसके बारे में कुछ समझ होती है।
* **ज्ञान** वह जानकारी है जो हमारे विश्व मॉडल में एकीकृत होती है। उदाहरण के लिए, जब हम सीखते हैं कि कंप्यूटर क्या है, तो हमें इसके काम करने के तरीके, इसकी लागत, और इसे किस लिए उपयोग किया जा सकता है, के बारे में कुछ विचार आने लगते हैं। ये आपस में संबंधित अवधारणाओं का नेटवर्क हमारे ज्ञान को बनाता है।
* **बुद्धिमत्ता** हमारे विश्व की समझ का एक और स्तर है, और यह *मेटा-ज्ञान* का प्रतिनिधित्व करता है, जैसे कि ज्ञान का उपयोग कब और कैसे किया जाना चाहिए।

<img src="images/DIKW_Pyramid.png" width="30%"/>

*छवि [Wikipedia](https://commons.wikimedia.org/w/index.php?curid=37705247) से, By Longlivetheux - स्वामित्व कार्य, CC BY-SA 4.0*

इस प्रकार, **ज्ञान प्रतिनिधित्व** की समस्या यह है कि किसी कंप्यूटर के अंदर ज्ञान को डेटा के रूप में प्रतिनिधित्व करने के लिए कुछ प्रभावी तरीका ढूंढना है, ताकि इसे स्वचालित रूप से उपयोग किया जा सके। इसे एक स्पेक्ट्रम के रूप में देखा जा सकता है:

![ज्ञान प्रतिनिधित्व स्पेक्ट्रम](../../../../translated_images/knowledge-spectrum.b60df631852c0217e941485b79c9eee40ebd574f15f18609cec5758fcb384bf3.hi.png)

> छवि [Dmitry Soshnikov](http://soshnikov.com) द्वारा

* बाईं ओर, बहुत सरल प्रकार के ज्ञान प्रतिनिधित्व हैं जिन्हें कंप्यूटर द्वारा प्रभावी रूप से उपयोग किया जा सकता है। सबसे सरल एक एल्गोरिदमिक है, जब ज्ञान को कंप्यूटर प्रोग्राम द्वारा प्रस्तुत किया जाता है। हालाँकि, यह ज्ञान को प्रस्तुत करने का सबसे अच्छा तरीका नहीं है, क्योंकि यह लचीला नहीं है। हमारे सिर में ज्ञान अक्सर गैर-एल्गोरिदमिक होता है।
* दाईं ओर, प्राकृतिक पाठ जैसे प्रतिनिधित्व हैं। यह सबसे शक्तिशाली है, लेकिन स्वचालित तर्क के लिए उपयोग नहीं किया जा सकता है।

> ✅ एक मिनट के लिए सोचें कि आप अपने सिर में ज्ञान को कैसे प्रस्तुत करते हैं और इसे नोट्स में परिवर्तित करते हैं। क्या कोई विशेष प्रारूप है जो आपको याद रखने में मदद करता है?

## कंप्यूटर ज्ञान प्रतिनिधित्वों का वर्गीकरण

हम विभिन्न कंप्यूटर ज्ञान प्रतिनिधित्व विधियों को निम्नलिखित श्रेणियों में वर्गीकृत कर सकते हैं:

* **नेटवर्क प्रतिनिधित्व** इस तथ्य पर आधारित हैं कि हमारे सिर में आपस में जुड़े अवधारणाओं का एक नेटवर्क होता है। हम कंप्यूटर के अंदर ग्राफ के रूप में उसी नेटवर्क को पुन: उत्पन्न करने का प्रयास कर सकते हैं - जिसे **सेमांटिक नेटवर्क** कहा जाता है।

1. **ऑब्जेक्ट-एट्रिब्यूट-वैल्यू ट्रिपलेट्स** या **एट्रिब्यूट-वैल्यू पेयर**। चूंकि एक ग्राफ को कंप्यूटर के अंदर नोड्स और एजेस की सूची के रूप में प्रस्तुत किया जा सकता है, हम एक सेमांटिक नेटवर्क को ट्रिपलेट्स की सूची द्वारा प्रस्तुत कर सकते हैं, जिसमें ऑब्जेक्ट, एट्रिब्यूट और वैल्यू होती है। उदाहरण के लिए, हम प्रोग्रामिंग भाषाओं के बारे में निम्नलिखित ट्रिपलेट्स बनाते हैं:

ऑब्जेक्ट | एट्रिब्यूट | वैल्यू
-------|-----------|------
Python | है | अनटाइप्ड-भाषा
Python | द्वारा आविष्कृत | Guido van Rossum
Python | ब्लॉक-सिंटैक्स | इंडेंटेशन
अनटाइप्ड-भाषा | नहीं है | टाइप परिभाषाएँ

> ✅ सोचें कि ट्रिपलेट्स का उपयोग अन्य प्रकार के ज्ञान को प्रस्तुत करने के लिए कैसे किया जा सकता है।

2. **हाइरार्किकल प्रतिनिधित्व** इस तथ्य पर जोर देते हैं कि हम अक्सर अपने सिर के अंदर वस्तुओं की एक पदानुक्रम बनाते हैं। उदाहरण के लिए, हम जानते हैं कि कैनरी एक पक्षी है, और सभी पक्षियों के पंख होते हैं। हमें यह भी कुछ विचार है कि कैनरी आमतौर पर किस रंग की होती है, और उनकी उड़ान गति क्या होती है।

   - **फ्रेम प्रतिनिधित्व** प्रत्येक वस्तु या वस्तुओं की श्रेणी का प्रतिनिधित्व करने के लिए एक **फ्रेम** का उपयोग करता है जिसमें **स्लॉट्स** होते हैं। स्लॉट्स के पास संभावित डिफ़ॉल्ट मान, मान प्रतिबंध, या स्टोर की गई प्रक्रियाएँ हो सकती हैं जिन्हें किसी स्लॉट के मान को प्राप्त करने के लिए कॉल किया जा सकता है। सभी फ्रेम एक वस्तु पदानुक्रम के समान एक पदानुक्रम बनाते हैं जो वस्तु-उन्मुख प्रोग्रामिंग भाषाओं में होता है।
   - **परिदृश्य** विशेष प्रकार के फ्रेम होते हैं जो समय में विकसित होने वाली जटिल स्थितियों का प्रतिनिधित्व करते हैं।

**Python**

स्लॉट | वैल्यू | डिफ़ॉल्ट वैल्यू | अंतराल |
-----|-------|---------------|----------|
नाम | Python | | |
है-एक | अनटाइप्ड-भाषा | | |
वेरिएबल केस | | CamelCase | |
प्रोग्राम लंबाई | | | 5-5000 लाइनों |
ब्लॉक सिंटैक्स | इंडेंट | | |

3. **प्रक्रियात्मक प्रतिनिधित्व** ज्ञान को उन क्रियाओं की सूची के रूप में प्रस्तुत करने पर आधारित हैं जिन्हें एक निश्चित स्थिति होने पर निष्पादित किया जा सकता है।
   - उत्पादन नियम यदि-तो कथन हैं जो हमें निष्कर्ष निकालने की अनुमति देते हैं। उदाहरण के लिए, एक डॉक्टर के पास एक नियम हो सकता है जिसमें कहा गया है कि **यदि** एक मरीज को उच्च बुखार है **या** रक्त परीक्षण में C-रिएक्टिव प्रोटीन का उच्च स्तर है **तो** उसे सूजन है। जब हम किसी स्थिति का सामना करते हैं, तो हम सूजन के बारे में निष्कर्ष निकाल सकते हैं, और फिर इसका उपयोग आगे के तर्क में कर सकते हैं।
   - एल्गोरिदम को प्रक्रियात्मक प्रतिनिधित्व के एक अन्य रूप के रूप में माना जा सकता है, हालाँकि इन्हें ज्ञान-आधारित प्रणालियों में लगभग कभी सीधे उपयोग नहीं किया जाता है।

4. **तर्क** को मूल रूप से अरस्तू द्वारा सार्वभौमिक मानव ज्ञान का प्रतिनिधित्व करने के तरीके के रूप में प्रस्तावित किया गया था।
   - प्रेडिकेट लॉजिक एक गणितीय सिद्धांत के रूप में इतना समृद्ध है कि इसे गणनायोग्य नहीं माना जा सकता, इसलिए इसका सामान्यतः उपयोग किया जाने वाला कुछ उपसमुच्चय होता है, जैसे कि प्रोलॉग में उपयोग किए जाने वाले हॉर्न क्लॉज़।
   - वर्णनात्मक तर्क एक तार्किक प्रणाली का परिवार है जिसका उपयोग वस्तुओं की पदानुक्रम और वितरित ज्ञान प्रतिनिधित्व जैसे *सेमांटिक वेब* के बारे में प्रतिनिधित्व और तर्क करने के लिए किया जाता है।

## विशेषज्ञ प्रणाली

Symbolic AI की प्रारंभिक सफलताओं में से एक तथाकथित **विशेषज्ञ प्रणाली** थी - कंप्यूटर प्रणाली जो कुछ सीमित समस्या डोमेन में विशेषज्ञ के रूप में कार्य करने के लिए डिज़ाइन की गई थी। ये एक या एक से अधिक मानव विशेषज्ञों से निकाले गए **ज्ञान आधार** पर आधारित थीं, और इनमें एक **व्युत्पत्ति इंजन** था जो इसके शीर्ष पर कुछ तर्क करता था।

![मानव आर्किटेक्चर](../../../../translated_images/arch-human.5d4d35f1bba3ab1cdfda96af2f10b89574eb31e9796d0e3011cd9beda1c35112.hi.png) | ![ज्ञान-आधारित प्रणाली](../../../../translated_images/arch-kbs.3ec5c150b09fa8dadc2beb0931a4983c9e2b03913a89eebcc103b5bb841b0212.hi.png)
---------------------------------------------|------------------------------------------------
मानव तंत्रिका प्रणाली की सरल संरचना | ज्ञान-आधारित प्रणाली की आर्किटेक्चर

विशेषज्ञ प्रणालियाँ मानव तर्क प्रणाली की तरह बनाई जाती हैं, जिसमें **शॉर्ट-टर्म मेमोरी** और **लॉन्ग-टर्म मेमोरी** होती है। इसी प्रकार, ज्ञान-आधारित प्रणालियों में हम निम्नलिखित घटकों में अंतर करते हैं:

* **समस्या मेमोरी**: इसमें वर्तमान में हल की जा रही समस्या के बारे में ज्ञान होता है, जैसे कि एक मरीज का तापमान या रक्तचाप, क्या उसे सूजन है या नहीं, आदि। इस ज्ञान को **स्थिर ज्ञान** भी कहा जाता है, क्योंकि यह उस समस्या के बारे में जो हम वर्तमान में जानते हैं, का एक स्नैपशॉट है - जिसे *समस्या स्थिति* कहा जाता है।
* **ज्ञान आधार**: यह समस्या डोमेन के बारे में दीर्घकालिक ज्ञान का प्रतिनिधित्व करता है। इसे मानव विशेषज्ञों से मैन्युअल रूप से निकाला जाता है, और यह परामर्श से परामर्श में नहीं बदलता। क्योंकि यह हमें एक समस्या स्थिति से दूसरी समस्या स्थिति में नेविगेट करने की अनुमति देता है, इसे **गतिशील ज्ञान** भी कहा जाता है।
* **व्युत्पत्ति इंजन**: यह समस्या स्थिति स्थान में खोजने की पूरी प्रक्रिया का संचालन करता है, जब आवश्यक हो तो उपयोगकर्ता से प्रश्न पूछता है। यह प्रत्येक स्थिति पर लागू होने वाले सही नियमों को खोजने के लिए भी जिम्मेदार है।

उदाहरण के लिए, आइए एक जानवर को उसके शारीरिक लक्षणों के आधार पर पहचानने वाली विशेषज्ञ प्रणाली पर विचार करें:

![AND-OR पेड़](../../../../translated_images/AND-OR-Tree.5592d2c70187f283703c8e9c0d69d6a786eb370f4ace67f9a7aae5ada3d260b0.hi.png)

> छवि [Dmitry Soshnikov](http://soshnikov.com) द्वारा

यह आरेख एक **AND-OR पेड़** कहा जाता है, और यह उत्पादन नियमों के एक सेट का ग्राफिकल प्रतिनिधित्व है। ज्ञान को विशेषज्ञ से निकालने के आरंभ में पेड़ खींचना उपयोगी होता है। कंप्यूटर के अंदर ज्ञान को प्रस्तुत करने के लिए नियमों का उपयोग करना अधिक सुविधाजनक है:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

आप देख सकते हैं कि नियम के बाईं ओर की प्रत्येक स्थिति और क्रिया मूल रूप से ऑब्जेक्ट-एट्रिब्यूट-वैल्यू (OAV) ट्रिपलेट्स हैं। **कार्यशील मेमोरी** उन OAV ट्रिपलेट्स का सेट है जो वर्तमान में हल की जा रही समस्या के लिए हैं। एक **नियम इंजन** उन नियमों की खोज करता है जिनकी स्थिति संतुष्ट होती है और उन्हें लागू करता है, कार्यशील मेमोरी में एक और ट्रिपलेट जोड़ता है।

> ✅ एक विषय पर अपना खुद का AND-OR पेड़ बनाएं जो आपको पसंद हो!

### आगे बनाम पीछे व्युत्पत्ति

उपरोक्त प्रक्रिया को **आगे व्युत्पत्ति** कहा जाता है। यह समस्या के बारे में उपलब्ध प्रारंभिक डेटा के साथ शुरू होती है जो कार्यशील मेमोरी में है, और फिर निम्नलिखित तर्क चक्र को निष्पादित करती है:

1. यदि लक्षित एट्रिब्यूट कार्यशील मेमोरी में मौजूद है - रुकें और परिणाम दें
2. उन सभी नियमों की खोज करें जिनकी स्थिति वर्तमान में संतुष्ट है - नियमों का **संघर्ष सेट** प्राप्त करें।
3. **संघर्ष समाधान** करें - इस चरण पर निष्पादित होने वाले एक नियम का चयन करें। संघर्ष समाधान रणनीतियों के विभिन्न प्रकार हो सकते हैं:
   - ज्ञान आधार में पहले लागू होने वाले नियम का चयन करें
   - एक यादृच्छिक नियम का चयन करें
   - एक *अधिक विशिष्ट* नियम का चयन करें, अर्थात वह जो "बाईं ओर" (LHS) में सबसे अधिक स्थितियों को पूरा करता है
4. चयनित नियम को लागू करें और समस्या स्थिति में नया ज्ञान जोड़ें
5. चरण 1 से दोहराएँ।

हालांकि, कुछ मामलों में हम समस्या के बारे में खाली ज्ञान के साथ शुरू करना चाह सकते हैं, और ऐसे प्रश्न पूछना चाहते हैं जो हमें निष्कर्ष पर पहुँचने में मदद करेंगे। उदाहरण के लिए, जब चिकित्सा निदान करते हैं, तो हम आमतौर पर मरीज का निदान करने से पहले सभी चिकित्सा विश्लेषण नहीं करते हैं। हम निर्णय लेने की आवश्यकता होने पर विश्लेषण करना चाहते हैं।

इस प्रक्रिया को **पीछे व्युत्पत्ति** के रूप में मॉडल किया जा सकता है। यह **लक्ष्य** द्वारा संचालित होती है - वह एट्रिब्यूट मान जिसे हम खोजने के लिए देख रहे हैं:

1. सभी नियमों का चयन करें जो हमें एक लक्ष्य का मान दे सकते हैं (अर्थात, लक्ष्यों के साथ RHS ("दाईं ओर")) - एक संघर्ष सेट
1. यदि इस एट्रिब्यूट के लिए कोई नियम नहीं हैं, या कोई नियम कहता है कि हमें उपयोगकर्ता से मान पूछना चाहिए - पूछें, अन्यथा:
1. एक नियम का चयन करने के लिए संघर्ष समाधान रणनीति का उपयोग करें जिसे हम *परिकल्पना* के रूप में उपयोग करेंगे - हम इसे साबित करने का प्रयास करेंगे
1. नियम के LHS में सभी एट्रिब्यूट्स के लिए इस प्रक्रिया को पुनरावृत्त रूप से दोहराएं, उन्हें लक्ष्यों के रूप में साबित करने का प्रयास करें
1. यदि किसी भी बिंदु पर प्रक्रिया विफल होती है - चरण 3 में एक अन्य नियम का उपयोग करें।

> ✅ किन स्थितियों में आगे व्युत्पत्ति अधिक उपयुक्त है? पीछे व्युत्पत्ति के बारे में क्या?

### विशेषज्ञ प्रणालियों को लागू करना

विशेषज्ञ प्रणालियों को विभिन्न उपकरणों का उपयोग करके लागू किया जा सकता है:

* उन्हें किसी उच्च स्तर की प्रोग्रामिंग भाषा में सीधे प्रोग्राम करना। यह सबसे अच्छा विचार नहीं है, क्योंकि ज्ञान-आधारित प्रणाली का मुख्य लाभ यह है कि ज्ञान व्युत्पत्ति से अलग होता है, और संभावित रूप से एक समस्या डोमेन विशेषज्ञ को व्युत्पत्ति प्रक्रिया के विवरण को समझे बिना नियम लिखने में सक्षम होना चाहिए।
* **विशेषज्ञ प्रणाली शेल** का उपयोग करना, यानी एक प्रणाली जो किसी ज्ञान प्रतिनिधित्व भाषा का उपयोग करके ज्ञान से भरी जाती है।

## ✍️ व्यायाम: पशु व्युत्पत्ति

आगे और पीछे व्युत्पत्ति विशेषज्ञ प्रणाली को लागू करने के उदाहरण के लिए [Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) देखें।

> **नोट**: यह उदाहरण अपेक्षाकृत सरल है, और केवल यह विचार देता है कि एक विशेषज्ञ प्रणाली कैसी दिखती है। जब आप ऐसी प्रणाली बनाना शुरू करते हैं, तो आप केवल तब कुछ *बुद्धिमान* व्यवहार देखेंगे जब आप नियमों की एक निश्चित संख्या तक पहुँचेंगे, लगभग 200+. किसी बिंदु पर, नियम बहुत जटिल हो जाते हैं कि सभी को याद रखना कठिन हो जाता है, और इस बिंदु पर आप यह सोचने लगते हैं कि प्रणाली कुछ निर्णय क्यों लेती है। हालाँकि, ज्ञान-आधारित प्रणालियों की महत्वपूर्ण विशेषता यह है कि आप हमेशा यह *व्याख्या* कर सकते हैं कि किसी भी निर्णय को कैसे लिया गया।

## ऑंटोलॉजी और सेमांटिक वेब

20वीं सदी के अंत में एक पहल हुई थी कि ज्ञान प्रतिनिधित्व का उपयोग इंटरनेट संसाधनों को एनोटेट करने के लिए किया जाए, ताकि उन संसाधनों को खोजा जा सके जो बहुत विशिष्ट प्रश्नों के अनुरूप हों। इस आंदोलन को **सेमांटिक वेब** कहा गया, और यह कई अवधारणाओं पर निर्भर करता था:

- **[विवरण तर्क](https://en.wikipedia.org/wiki/Description_logic)** (DL) पर आधारित एक विशेष ज्ञान प्रतिनिधित्व। यह फ्रेम ज्ञान प्रतिनिधित्व के समान है, क्योंकि यह गुणों के साथ वस्तुओं की एक पदानुक्रम बनाता है, लेकिन इसमें औपचारिक तार्किक अर्थ और व्युत्पत्ति होती है। DL का एक पूरा परिवार है जो अभिव्यक्तित्व और व्युत्पत्ति की एल्गोरिदमिक जटिलता के बीच संतुलन बनाता है।
- वितरित ज्ञान प्रतिनिधित्व, जहां सभी अवधारणाएँ एक वैश्विक URI पहचानकर्ता द्वारा प्रस्तुत की जाती हैं, जिससे यह संभव होता है कि ज्ञान की पदानुक्रमें बनाई जा सकें जो इंटरनेट को फैलाएं।
- ज्ञान विवरण के लिए XML-आधारित भाषाओं का एक परिवार: RDF (रिसोर्स विवरण ढांचा), RDFS (RDF स्कीमा), OWL (ऑन्टोलॉजी वेब भाषा)।

सेमांटिक

**अस्वीकृति**:  
यह दस्तावेज़ मशीन-आधारित एआई अनुवाद सेवाओं का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। मूल दस्तावेज़ को उसकी मूल भाषा में प्राधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। हम इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए जिम्मेदार नहीं हैं।